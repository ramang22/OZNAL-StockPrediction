
```{r echo = T, results = 'hide'}
# imports
source("../R_code/OZNAL_utils.R")
library("readxl")
library(magrittr)
library(corrplot)
library(ggplot2)
library(nortest)
library(RColorBrewer)
library(tidyverse)
library(gridExtra)
library(knitr)
library(psych)

`%>%` <- magrittr::`%>%` # pipe operátor
```
 

## Hypotézy

Na zákldade dostupných dát a našich cielov sme identifikovali nasledovné hypotézy.

TODO Argumenty pre hypothesis-free vs hypothesis-driven vs endpointy

### Hypotéza 1 

Dokáže "Šum" na reddite ohľadom jedného symbolu ovplyvniť jeho rast na dennej baze (change)?

**Overenie** : Potvrdenie existencie korelácie medzi jednotlivými stĺpcami šumu a stĺpcom change, následne pomocou testu dokázať že sú závislé.  

### Hypotéza 2 

Ovplyní zmena hodnoty stocku sentiment jednotlivých príspevkov? 

**Overenie** : Potvrdenie existencie korelácie medzi stĺpcom change a stĺpcom sentiment, následne pomocou testu dokázať že sú závislé.  

### Hypotéza 3 

Čím je väčší "šum" na reddite tým je väčšia volume stocku? 

**Overenie** : Potvrdenie existencie korelácie mmedzi jednotlivými stĺpcami šumu a stĺpcom volume, následne pomocou testu dokázať že sú závislé.  

### Hypotéza 4 

Existuje súvislosť medzi rastúcimi stockmi, na základe "šumu" z redditu?

**Overenie** : Potvrdenie existencie korelácie mmedzi zmenou šumu a stĺpcami, ktoré reprezentujú hodnoty stocku, následne pomocou testu dokázať že sú závislé. 

### Hypotéza 5 
Dokáže reddit ovplyvniť rast stocku priebežne (v celých dátach) od 2019 do 2021? 

**Overenie** : Korelácia ???

### Hypotéza 6 

Dokáže reddit ovplyvniť rast stocku dopredu o týždeň? 

**Overenie** : Korelácia medzi šumom a maximálnou hodnotou stocku dopredu

## Základny opis dát

```{r}
df <- read.csv("../data/dataset_final.csv")
df <- df[,-2]
head(df)
```
```{r}
summary(df)
```
Finálny dataset obsahuje 98208 riadkov a má 25 stĺpcov. 

Taktiež sme sledovali či sú dáta z normálového rozdelnia pomocou Anderson-Darling testu. Tento test sme použili namiesto Shapiro–Wilk testu lebo dokáže pracovať aj s viac ako 5000 záznami. Pri použítí Anderson-Darlingu testu nám vyšlo že žiadne dáta niesu z normálovej distribúcie, takže to je prvý krok, ktorý budeme musiet vykonať pri čistený datasetu.

**Stĺpce sú nasledovné:**

* upvote_ratio - Tento stĺpec hovorí o pomere $upvote/downvote$ na príspevkoch pre jednen ticker v konkrétnom dni. 

* symbol - označenie akcie, ticker.

* date - timestamp, konkrétny deň.

* score - $count\_upvotes-count\_downvotes$, ako boli príspevky hodnotené.
 
```{r}
ad.test(df$score)
```
 
 
* awards - koľko krát boli dané príspevku, pre konkrétny ticker "boostnuté".

```{r}
ad.test(df$awards)
```


* sentiment - NLP hodnota, ktorá reprezentuje či príspevky a komentáre pre daný ticker mali pozitívny alebo negatívny sentiment.

```{r}
ad.test(df$sentiment)
```


* count - počet, ktorý hovorí o tom koľko krát bol daný ticker spomenutý v daný deň.

```{r}
ad.test(df$count)
```


* Open - otváracia cena akcie v daný deň.

```{r}
ad.test(df$Open)
```


* High - maximálna cena akcie v daný deň.

```{r}
ad.test(df$High)
```


* Low - minimálna cena akcie v daný deň.

```{r}
ad.test(df$Low)
```


* Close - zatváracia cena akcie v daný deň. 

```{r}
ad.test(df$Close)
```

* Adj.Close - stock price ktory je adjusted tak aby reflektovaö naozajstnu cenu

```{r}
ad.test(df$Adj.Close)
```

* Volume - cena predaných akcií v daný deň.

```{r}
ad.test(df$Volume)
```

* float - počet akcií 

```{r}
ad.test(df$float)
```

* spread - $High/Close$, rozsah zmeny ceny akcie v daný deň

```{r}
ad.test(df$spread)
```

* change - $Close/Open$, ako sa zmenila cena akcie v daný deň

```{r}
ad.test(df$change)
```

* peak - $High/Open$, o koľko narástla maximálna cena akcie v daný deň

```{r}
ad.test(df$peak)
```

* trough - $Open/Low$, o koľko klesla hodota akcie v daný deň

```{r}
ad.test(df$trough)
```

* min7 - minimálna hodnota akcie v uplynutých 7 dní

```{r}
ad.test(df$min7)
```

* max7 - maximálna hodnota akcie v uplynutých 7 dní

```{r}
ad.test(df$max7)
```

* min30 - minimálna hodota akcie v uplynutých 30 dní

```{r}
ad.test(df$min30)
```

* max30 - maximálna hodnota akcie v uplynutých 30 dní

```{r}
ad.test(df$max30)
```

* max7plus - maximálna cena akcie v nasledujúcich 7 dňoch

```{r}
ad.test(df$max7plus)
```

* min7plus - minimálna cena akcie v nasledujúcich 7 dňoch

```{r}
ad.test(df$min7plus)
```

* marketCap - hodna všetkých akcií konkrétneho tickera v daný deň

```{r}
ad.test(df$marketCap)
```
Vidíme zopár chýbajúcich hodnôt, ktoré budeme musiet v nasledujúcom kroku doplniť alebo odstrániť. Tieto hodnoty chýbajú z dôvodu spájania dát, pričom jednotlivé tickery neobsahovali hodnotu float.

```{r}
missing.values <- df %>%
    gather(key = "key", value = "val") %>%
    mutate(is.missing = is.na(val)) %>%
    group_by(key, is.missing) %>%
    summarise(num.missing = n()) %>%
    filter(is.missing==T) %>%
    select(-is.missing) %>%
    arrange(desc(num.missing)) 
    
missing.values  %>% kable()
```
 

## Exploratory data analysis (EDA)

Pre každý stĺpec sme spravili samostatnú EDA analýzu, ktorá obsahuje opis štatistických hodnôt jednotlivého stĺpca a 4 grafy. 

* QQPlot - hovorí o tom ako je rozdelenie odlišné od norm. rozdelenia
* Boxplot - graficky zobrazí štatisického hodnoty daného stĺpca, môžeme na ňom sledovať možných outlayerov
* Histogram - ukazuje nám rozdelenie stĺpca 
* Graf hustoty

Následne pre každý stĺpec zhrnieme problémy alebo zaujímavosti, ktoré sme objavili. 

### Upvote Ratio

Kedže hovorí o pomere $upvote/downvote$, tak sme nezistili žiadnych chybných outlayerov. Bude potrebné dáta trošku transformovať, normalizovať.

```{r}
describe(df$upvote_ratio)
```


```{r}
p1 <- ggplot(df, mapping = aes(sample=upvote_ratio)) + stat_qq() + stat_qq_line()
p2 <- ggplot(df, aes(x=upvote_ratio)) + geom_boxplot(notch=TRUE) + coord_flip()
p3 <- ggplot(df, aes(x=upvote_ratio)) + geom_histogram(color="black", fill="white")
p4 <- ggplot(df, aes(x=upvote_ratio)) + geom_density(color="black", fill="pink", alpha=.3)

grid.arrange(p1, p2,p3,p4, nrow = 2)
```


### Symbol

Je to kategorická premenná, pri ktorej EDA analýze sme nemohli využit numerické grafy. Taktiež sme zistili že v datasete máme veľký bias v podobe jednotlivých symbolov. Pri tvorbe datasetu sme nedbali na to že jednotlivé symboly môžu reprezentovať aj anglické slová. Takže tieto symboly, ktoré sú aj anglické slová musíme odstrániť v nasledujúcom kroku.
```{r}
length(unique(df$symbol))
```

```{r}
tickers <- df %>% group_by(symbol) %>% tally()
head(tickers)
ggplot(data=tickers, aes(x=symbol, y=n)) +
  geom_bar(stat="identity")
```
```{r}
top10tickers <- tickers[order(-tickers$n),][1:10,]
ggplot(data=top10tickers, aes(x=symbol, y=n)) + geom_bar(stat="identity")
```

### Date

Dátum, premenná len na reprezentáciu času v dátach. 

```{r}
cat("Prvy datum :",head(df$date,1),"\nPosledny datum :",tail(df$date,1))
```


### Score

Premenná skóre môže obsahovať aj negatívne a aj pozitívne hodnoty, jednotlivý outlayeri na boxplote niesu outlayeri ale sú to len príspevky, ktoré boli vysoko hodnotené. Avšak daný stĺpec bude treba normalizovať.

```{r}
describe(df$score)
```


```{r}
p1 <- ggplot(df, mapping = aes(sample=score)) + stat_qq() + stat_qq_line()
p2 <- ggplot(df, aes(x=score)) + geom_boxplot(notch=TRUE) + coord_flip()
p3 <- ggplot(df, aes(x=score)) + geom_histogram(color="black", fill="white")
p4 <- ggplot(df, aes(x=score)) + geom_density(color="black", fill="pink", alpha=.3)

grid.arrange(p1, p2,p3,p4, nrow = 2)
```

### Awards

Táto premmená nemôže byť záporná ale nenachádzajú sa tu žiadne záporne hodnoty. Takže stĺpec je v poriadku avšak bude treba normalizovať.

```{r}
describe(df$awards)
```


```{r}
p1 <- ggplot(df, mapping = aes(sample=awards)) + stat_qq() + stat_qq_line()
p2 <- ggplot(df, aes(x=awards)) + geom_boxplot(notch=TRUE) + coord_flip()
p3 <- ggplot(df, aes(x=awards)) + geom_histogram(color="black", fill="white")
p4 <- ggplot(df, aes(x=awards)) + geom_density(color="black", fill="pink", alpha=.3)

grid.arrange(p1, p2,p3,p4, nrow = 2)
```

### Sentiment

Sentiment podobne ako skóre môže dosahovať kladnú ale aj zápornú hodnotu ale nemá obmedzenie. Stĺpec bude treba normalizovať.

```{r}
describe(df$sentiment)
```


```{r}
p1 <- ggplot(df, mapping = aes(sample=sentiment)) + stat_qq() + stat_qq_line()
p2 <- ggplot(df, aes(x=sentiment)) + geom_boxplot(notch=TRUE) + coord_flip()
p3 <- ggplot(df, aes(x=sentiment)) + geom_histogram(color="black", fill="white")
p4 <- ggplot(df, aes(x=sentiment)) + geom_density(color="black", fill="pink", alpha=.3)

grid.arrange(p1, p2,p3,p4, nrow = 2)
```

### Count

Count by nemal byť záporný a ani nulový čo je v poriadku avšak stĺpec bude treba normalizovať.

```{r}
describe(df$count)
```


```{r}
p1 <- ggplot(df, mapping = aes(sample=count)) + stat_qq() + stat_qq_line()
p2 <- ggplot(df, aes(x=count)) + geom_boxplot(notch=TRUE) + coord_flip()
p3 <- ggplot(df, aes(x=count)) + geom_histogram(color="black", fill="white")
p4 <- ggplot(df, aes(x=count)) + geom_density(color="black", fill="pink", alpha=.3)

grid.arrange(p1, p2,p3,p4, nrow = 2)
```

### Open

Jednotlivé hodnoty tohto stĺpca by nemali súvisieť medzi sebou. Treba normalizovať.

```{r}
describe(df$Open)
```


```{r}
p1 <- ggplot(df, mapping = aes(sample=Open)) + stat_qq() + stat_qq_line()
p2 <- ggplot(df, aes(x=Open)) + geom_boxplot(notch=TRUE) + coord_flip()
p3 <- ggplot(df, aes(x=Open)) + geom_histogram(color="black", fill="white")
p4 <- ggplot(df, aes(x=Open)) + geom_density(color="black", fill="pink", alpha=.3)

grid.arrange(p1, p2,p3,p4, nrow = 2)
```

### High

Jednotlivé hodnoty tohto stĺpca by nemali súvisieť medzi sebou. Treba normalizovať.

```{r}
describe(df$High)
```


```{r}
p1 <- ggplot(df, mapping = aes(sample=High)) + stat_qq() + stat_qq_line()
p2 <- ggplot(df, aes(x=High)) + geom_boxplot(notch=TRUE) + coord_flip()
p3 <- ggplot(df, aes(x=High)) + geom_histogram(color="black", fill="white")
p4 <- ggplot(df, aes(x=High)) + geom_density(color="black", fill="pink", alpha=.3)

grid.arrange(p1, p2,p3,p4, nrow = 2)
```

### Low

Jednotlivé hodnoty tohto stĺpca by nemali súvisieť medzi sebou. Treba normalizovať.

```{r}
describe(df$Low)
```


```{r}
p1 <- ggplot(df, mapping = aes(sample=Low)) + stat_qq() + stat_qq_line()
p2 <- ggplot(df, aes(x=Low)) + geom_boxplot(notch=TRUE) + coord_flip()
p3 <- ggplot(df, aes(x=Low)) + geom_histogram(color="black", fill="white")
p4 <- ggplot(df, aes(x=Low)) + geom_density(color="black", fill="pink", alpha=.3)

grid.arrange(p1, p2,p3,p4, nrow = 2)
```

### Close

Jednotlivé hodnoty tohto stĺpca by nemali súvisieť medzi sebou. Treba normalizovať.

```{r}
describe(df$Close)
```


```{r}
p1 <- ggplot(df, mapping = aes(sample=Close)) + stat_qq() + stat_qq_line()
p2 <- ggplot(df, aes(x=Close)) + geom_boxplot(notch=TRUE) + coord_flip()
p3 <- ggplot(df, aes(x=Close)) + geom_histogram(color="black", fill="white")
p4 <- ggplot(df, aes(x=Close)) + geom_density(color="black", fill="pink", alpha=.3)

grid.arrange(p1, p2,p3,p4, nrow = 2)
```

### Adj.Close

Jednotlivé hodnoty tohto stĺpca by nemali súvisieť medzi sebou. Treba normalizovať.

```{r}
describe(df$Adj.Close)
```


```{r}
p1 <- ggplot(df, mapping = aes(sample=Adj.Close)) + stat_qq() + stat_qq_line()
p2 <- ggplot(df, aes(x=Adj.Close)) + geom_boxplot(notch=TRUE) + coord_flip()
p3 <- ggplot(df, aes(x=Adj.Close)) + geom_histogram(color="black", fill="white")
p4 <- ggplot(df, aes(x=Adj.Close)) + geom_density(color="black", fill="pink", alpha=.3)

grid.arrange(p1, p2,p3,p4, nrow = 2)
```

### Volume

Jednotlivé hodnoty tohto stĺpca by nemali súvisieť medzi sebou. Treba normalizovať.

```{r}
describe(df$Volume)
```


```{r}
p1 <- ggplot(df, mapping = aes(sample=Volume)) + stat_qq() + stat_qq_line()
p2 <- ggplot(df, aes(x=Volume)) + geom_boxplot(notch=TRUE) + coord_flip()
p3 <- ggplot(df, aes(x=Volume)) + geom_histogram(color="black", fill="white")
p4 <- ggplot(df, aes(x=Volume)) + geom_density(color="black", fill="pink", alpha=.3)

grid.arrange(p1, p2,p3,p4, nrow = 2)
```

### Float

Obsahuje nan hodnoty, ktoré treba poriešiť asi vymazaním nan riadkov.

```{r}
describe(df$float)
```


```{r}
p1 <- ggplot(df, mapping = aes(sample=float)) + stat_qq() + stat_qq_line()
p2 <- ggplot(df, aes(x=float)) + geom_boxplot(notch=TRUE) + coord_flip()
p3 <- ggplot(df, aes(x=float)) + geom_histogram(color="black", fill="white")
p4 <- ggplot(df, aes(x=float)) + geom_density(color="black", fill="pink", alpha=.3)

grid.arrange(p1, p2,p3,p4, nrow = 2)
```

### Spread

Stĺpec je potrebné normalizovať.

```{r}
describe(df$spread)
```


```{r}
p1 <- ggplot(df, mapping = aes(sample=spread)) + stat_qq() + stat_qq_line()
p2 <- ggplot(df, aes(x=spread)) + geom_boxplot(notch=TRUE) + coord_flip()
p3 <- ggplot(df, aes(x=spread)) + geom_histogram(color="black", fill="white")
p4 <- ggplot(df, aes(x=spread)) + geom_density(color="black", fill="pink", alpha=.3)

grid.arrange(p1, p2,p3,p4, nrow = 2)
```

### Change

Stĺpec je potrebné normalizovať.

```{r}
describe(df$change)
```


```{r}
p1 <- ggplot(df, mapping = aes(sample=change)) + stat_qq() + stat_qq_line()
p2 <- ggplot(df, aes(x=change)) + geom_boxplot(notch=TRUE) + coord_flip()
p3 <- ggplot(df, aes(x=change)) + geom_histogram(color="black", fill="white")
p4 <- ggplot(df, aes(x=change)) + geom_density(color="black", fill="pink", alpha=.3)

grid.arrange(p1, p2,p3,p4, nrow = 2)
```

### Peak

Stĺpec je potrebné normalizovať.

```{r}
describe(df$peak)
```


```{r}
p1 <- ggplot(df, mapping = aes(sample=peak)) + stat_qq() + stat_qq_line()
p2 <- ggplot(df, aes(x=peak)) + geom_boxplot(notch=TRUE) + coord_flip()
p3 <- ggplot(df, aes(x=peak)) + geom_histogram(color="black", fill="white")
p4 <- ggplot(df, aes(x=peak)) + geom_density(color="black", fill="pink", alpha=.3)

grid.arrange(p1, p2,p3,p4, nrow = 2)
```

### Trough

Stĺpec je potrebné normalizovať.

```{r}
describe(df$trough)
```


```{r}
p1 <- ggplot(df, mapping = aes(sample=trough)) + stat_qq() + stat_qq_line()
p2 <- ggplot(df, aes(x=trough)) + geom_boxplot(notch=TRUE) + coord_flip()
p3 <- ggplot(df, aes(x=trough)) + geom_histogram(color="black", fill="white")
p4 <- ggplot(df, aes(x=trough)) + geom_density(color="black", fill="pink", alpha=.3)

grid.arrange(p1, p2,p3,p4, nrow = 2)
```

### Min7 - days

Stĺpec je potrebné normalizovať.

```{r}
describe(df$min7)
```


```{r}
p1 <- ggplot(df, mapping = aes(sample=min7)) + stat_qq() + stat_qq_line()
p2 <- ggplot(df, aes(x=min7)) + geom_boxplot(notch=TRUE) + coord_flip()
p3 <- ggplot(df, aes(x=min7)) + geom_histogram(color="black", fill="white")
p4 <- ggplot(df, aes(x=min7)) + geom_density(color="black", fill="pink", alpha=.3)

grid.arrange(p1, p2,p3,p4, nrow = 2)
```


### Max7 - days

Stĺpec je potrebné normalizovať.

```{r}
describe(df$max7)
```


```{r}
p1 <- ggplot(df, mapping = aes(sample=max7)) + stat_qq() + stat_qq_line()
p2 <- ggplot(df, aes(x=max7)) + geom_boxplot(notch=TRUE) + coord_flip()
p3 <- ggplot(df, aes(x=max7)) + geom_histogram(color="black", fill="white")
p4 <- ggplot(df, aes(x=max7)) + geom_density(color="black", fill="pink", alpha=.3)

grid.arrange(p1, p2,p3,p4, nrow = 2)
```

### Min30 - days

Stĺpec je potrebné normalizovať.

```{r}
describe(df$min30)
```


```{r}
p1 <- ggplot(df, mapping = aes(sample=min30)) + stat_qq() + stat_qq_line()
p2 <- ggplot(df, aes(x=min30)) + geom_boxplot(notch=TRUE) + coord_flip()
p3 <- ggplot(df, aes(x=min30)) + geom_histogram(color="black", fill="white")
p4 <- ggplot(df, aes(x=min30)) + geom_density(color="black", fill="pink", alpha=.3)

grid.arrange(p1, p2,p3,p4, nrow = 2)
```

### Max 30- days

Stĺpec je potrebné normalizovať.

```{r}
describe(df$max30)
```


```{r}
p1 <- ggplot(df, mapping = aes(sample=max30)) + stat_qq() + stat_qq_line()
p2 <- ggplot(df, aes(x=max30)) + geom_boxplot(notch=TRUE) + coord_flip()
p3 <- ggplot(df, aes(x=max30)) + geom_histogram(color="black", fill="white")
p4 <- ggplot(df, aes(x=max30)) + geom_density(color="black", fill="pink", alpha=.3)

grid.arrange(p1, p2,p3,p4, nrow = 2)
```

### Max7Plus - days

Stĺpec je potrebné normalizovať.

```{r}
describe(df$max7plus)
```


```{r}
p1 <- ggplot(df, mapping = aes(sample=max7plus)) + stat_qq() + stat_qq_line()
p2 <- ggplot(df, aes(x=max7plus)) + geom_boxplot(notch=TRUE) + coord_flip()
p3 <- ggplot(df, aes(x=max7plus)) + geom_histogram(color="black", fill="white")
p4 <- ggplot(df, aes(x=max7plus)) + geom_density(color="black", fill="pink", alpha=.3)

grid.arrange(p1, p2,p3,p4, nrow = 2)
```

### Min7Plus - days

Stĺpec je potrebné normalizovať.

```{r}
describe(df$min7plus)
```


```{r}
p1 <- ggplot(df, mapping = aes(sample=min7plus)) + stat_qq() + stat_qq_line()
p2 <- ggplot(df, aes(x=min7plus)) + geom_boxplot(notch=TRUE) + coord_flip()
p3 <- ggplot(df, aes(x=min7plus)) + geom_histogram(color="black", fill="white")
p4 <- ggplot(df, aes(x=min7plus)) + geom_density(color="black", fill="pink", alpha=.3)

grid.arrange(p1, p2,p3,p4, nrow = 2)
```

### Marketcap

Podobne ako float obashuje NaN hodnoty, ktoré je potrebné odstrániť.

```{r}
describe(df$marketCap)
```


```{r}
p1 <- ggplot(df, mapping = aes(sample=marketCap)) + stat_qq() + stat_qq_line()
p2 <- ggplot(df, aes(x=marketCap)) + geom_boxplot(notch=TRUE) + coord_flip()
p3 <- ggplot(df, aes(x=marketCap)) + geom_histogram(color="black", fill="white")
p4 <- ggplot(df, aes(x=marketCap)) + geom_density(color="black", fill="pink", alpha=.3)

grid.arrange(p1, p2,p3,p4, nrow = 2)
```

## Párová analýza

Na základe párovej analýzy jednotlivých stĺpcov, ktoré súvysia s definovanými hypotézami je veľmi tažké usúdiť či jednotlivé stĺpce spolu súvisia. Párová analýza môže vyzerať lepšie po normalizovaný dát. Taktiež je dobré doplniť nový stĺpec "šumu", ktorý by reprezentoval Score/Awards/Sentiments/Upvoteratio/Count.

```{r}
gmeDf <- df[df$symbol == "GME",]
```


### Korelačná analýza

Korelačná heatmapa, nám ukazuje náznaky korelácie či už kladnej alebo zápornej. Taktiež je zaujimáve ako sa zmení korelácia po upráve dát v 3 časti - čistenie dát. Aj keď pri korelácii je využitá spearmenova korelácia, na ktorú by nemala mať vplyv na normalizácia. 

```{r}
dfCorr <- df[ , purrr::map_lgl(df, is.numeric)]
M <-cor(dfCorr,method="spearman")
corrplot(M, type="upper",
         col=brewer.pal(n=8, name="RdYlBu"))
```


### Score/Awards/Sentiments/Upvoteratio/Count vs Change



```{r}
pairs(~ score + awards + sentiment + upvote_ratio + count + change, data = df)
pairs(~ score + awards + sentiment + upvote_ratio + count + change, data = gmeDf)
```
### Change/Spread/Trough/Peak vs Sentiment

```{r}
pairs(~ spread + trough + peak + change + sentiment, data = df)
pairs(~ spread + trough + peak + change + sentiment, data = gmeDf)
```

### Score/Awards/Sentiments/Upvoteratio/Count vs Volume

```{r}
pairs(~ score + awards + sentiment + upvote_ratio + count + Volume, data = df)
pairs(~ score + awards + sentiment + upvote_ratio + count + Volume, data = gmeDf)
```

### Plus Change vs Score/Awards/Sentiments/Upvoteratio/Count

```{r}
plusChange <- df[ which(df$change > 0), ]
plusChangeGme <- gmeDf[which(gmeDf$change > 0),]
pairs(~ score + awards + sentiment + upvote_ratio + count + change, data = plusChange)
pairs(~ score + awards + sentiment + upvote_ratio + count + change, data = plusChangeGme)
```

## Prečo sú naše dáta reprezentatívne?

Dôvod prečo sú naše dáta reprezentatívne je nasledovný. Všetky dáta, s ktorými pracujeme sú realné dáta. Dáta z redditu sú získavané pomocou reddit API, takže to niesu žiadne fake data. Podobne aj s stock price, market dátami, ktoré sú tiež reálne. Takže všetky dáta sú realne, nič nieje vymyslené-fake data. Reprezentujú presné chovania stock marketu a zároveň aj správanie sa reddite.

## Prečo je náš dataset unikátny

Náš dataset je unikátny lebo je uplne novo vytvorený práve pre účel tohoto zadania. Tým že vznikol spojeným dvoch rôznych datasetov, pridaním údajov z yahoo finance a transformáciou do nami potrebného tvaru. 
